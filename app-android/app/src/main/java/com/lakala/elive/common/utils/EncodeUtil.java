package com.lakala.elive.common.utils;import org.apache.commons.codec.DecoderException;import org.apache.commons.codec.binary.Base64;import org.apache.commons.codec.binary.Hex;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * 封装各种格式的编码解码工具类(来源于网络,保留作者). *  * 1.Commons-Codec的hex/base64 编码 2.Commons-Lang的xml/html escape * 3.JDK提供的URLEncoder *  * @author calvin */public abstract class EncodeUtil {	private static final String ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";	// 全局数组	private final static String[] strDigits = { "0", "1", "2", "3", "4", "5",			"6", "7", "8", "9", "a", "b", "c", "d", "e", "f" };	private static final String DEFAULT_URL_ENCODING = "UTF-8";	/**	 * Hex编码, byte[]->String.	 */	public static String encodeHex(byte[] input) {		return Hex.encodeHexString(input);	}	/**	 * Hex解码, String->byte[].	 */	public static byte[] decodeHex(String input) {		try {			return Hex.decodeHex(input.toCharArray());		} catch (DecoderException e) {			throw new IllegalStateException("Hex Decoder exception", e);		}	}	/**	 * Base64编码, byte[]->String.	 */	public static String encodeBase64(byte[] input) {		return Base64.encodeBase64String(input);	}	/**	 * Base64编码, URL安全(将Base64中的URL非法字符'+'和'/'转为'-'和'_', 见RFC3548).	 */	public static String encodeUrlSafeBase64(byte[] input) {		return Base64.encodeBase64URLSafeString(input);	}	/**	 * Base64解码, String->byte[].	 */	public static byte[] decodeBase64(String input) {		return Base64.decodeBase64(input);	}	/**	 * Base62(0_9A_Za_z)编码数字, long->String.	 */	public static String encodeBase62(long num) {		return alphabetEncode(num, 62);	}	/**	 * Base62(0_9A_Za_z)解码数字, String->long.	 */	public static long decodeBase62(String str) {		return alphabetDecode(str, 62);	}	private static String alphabetEncode(long num, int base) {		num = Math.abs(num);		StringBuilder sb = new StringBuilder();		for (; num > 0; num /= base) {			sb.append(ALPHABET.charAt((int) (num % base)));		}		return sb.toString();	}	private static long alphabetDecode(String str, int base) {		long result = 0;		for (int i = 0; i < str.length(); i++) {			result += ALPHABET.indexOf(str.charAt(i)) * Math.pow(base, i);		}		return result;	}	/**	 * @todo md5加密	 * @param plaintext	 * @return	 */	public static String encodeByMd5(String plaintext) {		String resultString = null;		try {			MessageDigest md = MessageDigest.getInstance("MD5");			// md.digest() 该函数返回值为存放哈希值结果的byte数组			resultString = byteToString(md.digest(plaintext.getBytes()));		} catch (NoSuchAlgorithmException ex) {			ex.printStackTrace();		}		return resultString;	}	public static String encodeBySha(String plaintext) {		String resultString = null;		try {			MessageDigest md = MessageDigest.getInstance("SHA");			// md.digest() 该函数返回值为存放哈希值结果的byte数组			resultString = byteToString(md.digest(plaintext.getBytes()));		} catch (NoSuchAlgorithmException ex) {			ex.printStackTrace();		}		return resultString;	}	// 返回形式为数字跟字符串	private static String byteToArrayString(byte bByte) {		int iRet = bByte;		if (iRet < 0) {			iRet += 256;		}		int iD1 = iRet / 16;		int iD2 = iRet % 16;		return strDigits[iD1] + strDigits[iD2];	}	// 转换字节数组为16进制字串	private static String byteToString(byte[] bByte) {		StringBuffer sBuffer = new StringBuffer();		for (int i = 0; i < bByte.length; i++) {			sBuffer.append(byteToArrayString(bByte[i]));		}		return sBuffer.toString();	}}